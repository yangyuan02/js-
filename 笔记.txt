/*************************************************************************************************/
1.new 操作符具体做了什么？(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)
    创建一个空的简单JavaScript对象（即{}）；
    链接该对象（即设置该对象的构造函数）到另一个对象 ；
    将步骤1新创建的对象作为this的上下文 ；
    如果该函数没有返回对象，则返回this
        var Fn = function() {}
        var fnObj = new Fn();

        1创建一个空对象
        var obj = new Object();
        2设置原型链
        obj._proto_ = Fn.prototype;
        3让Fn的this指向obj,并执行Fn的函数体
        var result = fn.call(obj)
        4判断Fn的返回值类型,如果是值类型,返回obj,如果是引用类型,就返回这个引用类型的对象
        if(typeof result === 'object) {
            fnObj = result;
        } else {
            fnObj = obj;
        }

/*************************************************************************************************/
2.原型链,原型,构造函数之间的关系总结
    Function Person {}
    const p1=new Person()
    p1.prototype是undefined
    实例p1上面是没有prototype而是通过__proto__访问到Person.prototype

    这就是原型链的过程
        p1.construct=Person
        p1.__proto__=Person.prototype
        Person.prototype.__proto__=Object.prototype
        Object.prototype.__proto__=null

    一切底层对象上的原型的原型链等于对象的原型
    Function.prototype__proto__=Object.prototype
    Array.prototype__proto__=Object.prototype

    一切底层对象原型链等于函数的原型
    Object.__proto__=Function.prototype
    Array.__proto__=Function.prototype

    一切底层对象上的构造函数等于构造器函数，
    对象上构造器来自Function
    Array.construct=Function
    String.construct=Function
    Object.construct=Function
    cons arr=[1,2]
    art.construct = Array

    一切对象上原型的构造函数等于自己本身
    Array.prototype.construct=Array
    Object.prototype.construct=Object

/*************************************************************************************************/
3.浏览器的解析过程
    1输入地址
    2浏览器查找域名的ip地址
        首先查看本地的hosts文件->本地的dns服务器->域服务器,查找到对应的ip地址,并且缓存
    3浏览器向web服务器发送一个http请求
        三次握手建立连接
    4建立连接之后
        会相应一些状态码200,304,500根据状态码做对应的处理
    5拿到数据后
    首先解析html，构建dom树->构建render->树布局render->树绘制render树

    解析过程中,浏览器首先会解析html文件构建dom树，然后解析css文件构建的渲染树，等到渲染树构建完成
    浏览器开始布局渲染树并将绘制到屏幕上

    浏览器自上而下执行,过程中如遇到css,img等,请求是异步的

    当文档加载过程中遇到js文件,html文档会挂起来渲染的线程,不仅要等待文档中js文件加载完毕，还有等待
    解析执行完毕,才可以恢复html文档渲染线程,因为js有可能修改dom,所以在编写代码尽可能吧js写在底部
    等html主体和css加载完之后在进行加载js

/*************************************************************************************************/
4.什么是回流，什么是重绘，有什么区别?
    当render tree中的一部分因为元素规模尺寸,布局,隐藏等改变而需要重新构建,这就称为----回流
        (添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变---回流)

    当render tree中的一些元素需要更新属性,而这些属性只是影响外观,风格,比如background-color称之为----重绘

    区别
        回流必将引起重绘,而重绘不一定引起回流
    优化
        比如改变样式的时候，不去改变他们每个的样式，而是直接改变className

/*************************************************************************************************/
5.http和https区别
    http请求/响应报文结构
        一个http请求报文由四个部分组成:请求行、请求头部、空行、请求数据
        请求行
            请求方法、Request URL、Request Method、Status Code，字段和http协议版本字段3个字段组成，分别用空格分隔
        Response Header
            请求头部
                Content-Encoding:压缩方式
                content-type数据类型格式
                server:服务器
                date:日期
                Authorization:授权信息
        Request Header
            Cookie:
            Host
            Origin:来源
            Referer:告诉服务器该网友从哪个页面过来的
        
    http缺点
        1通信使用明文,内容可能被窃听
        2不验证通信方身份,有可能遭遇伪装
        3无法证明报文完整性,有可能遭篡改(运营商劫持)
    http = tcp + ip
    https = ssl + tcp + ip

    ssl
        ssl可以分为两层
            ssl记录协议:它建立在可靠的传输记录协议之上(tcp),为高层次协议提供数据封装,压缩,加密等基本功能支持
            ssl握手协议:它建立在ssl记录协议之上,用于在实际的数据传输开始之前,通讯双方进行身份认证,协商加密算法、交换密匙

    对称密匙
        对称密匙加密,又称私钥加密,即信息的发送方和接受方用同一个密匙去加密和解密数据.它最大的优势是加/解密速度快,适合于
        大数据量进行加密,但密匙管理困难

    非对称加密
        又称公匙加密,它需要使用一对密匙来分别完成加密和解密,一个公开发布,即公开密匙,另一由用户自己密目保存,即私用密匙。信息发送者
        用公开密匙去加密,而信息接受者则用私用密匙去解密

    https工作原理
        1客户端发起https请求
            用户在浏览里输入一个https网站,然后连接到server的443端口
        2服务端的配置
            采用https协议的服务器必须要与一套数字证书,可以自己制作,也可以向组织申请,区别就是自己在颁发的证书需要客户端验证通过
        3传送证书
            这个证书其实公匙,只是包含了很多信息,如证书的颁发机构,过期时间等等
        4客户端解析证书
            这部分是有客户端tls来完成的,首先会验证公匙是否有效,比如颁发机构,过期时间,如果发现异常则弹出警告
        5传送加密信息
            这部分传送的是用证书加密后随机值(私钥),目的就是让服务端得到这个随机值,以后客户端和服务端的通信就可以通过这个随机值来进行加密
        6服务端解密信息
            服务端用私钥解密后,得到了客户端传过来随机值(私钥),然后把内容通过该值进行对称加密
        7传输加密后的信息
            这部分信息是服务端用私钥加密后的信息,可以在客户端还原
        8客户端解密信息
            客户端用之前生成私钥解密服务端传过来的信息,于是获取了解密后内容

    区别
    https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

/*************************************************************************************************/
6.TCP-三次握手和四次挥手简单理解
    三次握手
        三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。
        进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备
        原理
            1发送端首先发送一个带有SYN标志地数据包给接收方
            2接收方接受后,回传一个带有SYN/ACK标志的数据包传递确认信息,表示收到了
            3最后,发送方再回传一个带有ACK标志的数据包,代表我知道了,表示握手结束
        通俗说话
            Client:嘿,李四,是我,听到了吗?
            Server:我听到了,你能听到我的吗?
            Client:好的,我们互相都能听到对方的话,我们通信可以开始了
    四次挥手
    原理
        1.第一次挥手:Client发送一个FIN,用来关闭Client到Server的数据传递,Client进入FIN_WAIT_1状态
        2.第二次挥手:Server收到FIN后,发送一个ACK给给Client,确认序号为+1,Server进入CLOSE_WAIT状态
        3.第三次挥手:Server发送一个FIN,用来关闭Server到Client的数据传递,Server进入LAST_ACK状态
        4第四次挥手:Client收到FIN后,Client进入TIME_WAIT状态,接着发送一个ACK给Server,确认序号为+1,Server进入CLOSE状态
    通俗说话
        Client:我所有东西都说完了
        Server:我已经全部听到了,但是等等我,我还没有说完
        Server:好了,我已经说完了
        Client:好的,那我们的通信结束

/*************************************************************************************************/
7.事件的各个阶段
    捕获阶段-->目标阶段-->冒泡阶段
    document-->target-->document
    addEventList第三个参数设置true和false的区别已经非常清晰了
    true表示该元素在事件的捕获阶段(由外往内传递)响应事件
    false表示该元素在事件的冒泡阶段(由内向外传递)响应事件

/*************************************************************************************************/
8.web性能优化
    1压缩html/css/js使用Brotli比Gzip压缩效果更好,更快 chrome下 response header content-encoding:br
    2内嵌js一定要放在link css加载的前面,防止js阻塞css
    3使用框架代码和polyfill文件可以直接引用script标签不必打包到webpack中,利用缓存
    4使用静态域名js/css/img突破同域并发限制请求,并可以请求资源没带cookie请求
    5自定义ui,少用第三方ui库
    6使用阿里nginx模块nginx-http-concat做到多个文件合并一次请求
    7图片使用webp和图片可以根据尺寸返回
    8使用serviceWorker离线缓存
    9使用css:-webkit-touch-action:manipulation;touch-action:manipulation来解决300ms延迟代替fastClick.js
    10使用料加载技术优化图片加载
    11使用https和http2.0加载网页,使用tcp多路复用,网页更加安全
    12可以使用nodejs输出接口数据,前端直接拿到window上的变量数据,做出了避免客户端白屏问题 window._nuxt_ = <%-JSON.stringify(data)%>
    13preload/prefatch/dns-prefetch预加载/下个页面加载/dns与解析
    14async/defer延迟加载或异步加载
    15避免浏览器dom引起大量的重排和回流
    16服务端配置Cache-control max-age = 2592000
    17利用LocalStorage缓存接口数据,根据时间半小时/1天,减少服务器请求,定时清理

/*************************************************************************************************/
9.vue生命周期
    beforeCreate
        实例最近刚刚创建,元素dom和数据都还没有初始化
    Create
        数据data已经完成初始化,方法也可以调用,但dom未渲染,dom未挂载
    beforeMount
        dom未完成挂载,数据也为初始化完成,数据双向绑定显示{{}},这是因为vue采用虚拟dom技术
    mounted
        数据和dom都完成挂载,在删一个周期站位的数据给渲染进去,请求一般在这个位置
    beforeUpdate
        只要是页面数据改变了都会触发,数据更新之前，页面数据还是原来的数据,当你请求一个赋值一个数据时候会执行这个周期
    updated
        主要页面数据改变了都会触发,数据更新完毕,页面的数据是更新完成的,beforeUpdate和updated谨慎使用,因为页面更新数据都会触发
    beforeDestroy
        组件销毁前执行,清除定时器
    destroyed
        组件销毁,还是可以使用data数据和methods里的方法

/*************************************************************************************************/
10.computed、watch、methods的区别
    https://www.cnblogs.com/widgetbox/p/8954162.html
        computed
            当页面中有某些数据依赖其他数据进行变动的时候,可以使用计算属性,需要注意的是,就算在data中没有声明出要计算的变量,也可以写入
            计算属性默认只有getter,可以在需要的时候设置setter
                computed:{
                    fullName:{
                        get:function() {
                            return this.firstName + this.lastName
                        },
                        set:function() {
                            // ...
                        }
                    }
                }
        watch
            watch和computed很相似,watch用于观察和监听页面上的vue实例,当然大部分我们都会使用computed,数据开变化同时
            进行异步或者开销比较大,选择watch,watch为一个对象,键是需要观察的表达式,值是对应的回调函数,值也可以是方法名,
            如果data中没有相应的属性,是不能watch,这点和computed不一样
                watch: {
                    firstName: function(val) {
                        this.function = val + '' + this.lastName
                    },
                    lastName:function(val) {
                        this.function = this.firstName + '' + val
                    }
                }
        // 随着输入框变化而立即执行,输入才会监听(不会立即执行)     
        watch:{
            firstName(newName,oldName){
                this.fullName = newName + '' + this.lastName;
            }
        }
        watch:{
            firstName:{
                handler(newName, oldName){
                    this.fullName = newName + '' + this.lastName;
                },
                immediate:true, // 代表在watch里声明了firstName这个方法之后立即执行handler方法(立即执行)
                deep: true //深入观察,监听器会一层层往下遍历,给对象所有熟悉都加上监听器,性能开销就会非常大
            }
        }
        watch:{
            'obj.a':{ // 优化---监听字符串key的形式
                handler(newName,oldName) {

                }
            }
        }
        // 监听路由
        watch:{
            '$route'(to,from) {

            }
        }
        需要及时注销watch,当然我们写在组件中，他会随着组件消失而消失
        methods
            方法,只要调用就好重新执行一次,相应的有一些触发条件,在某些时候methods和computed看不出茶杯,运算量比较大就会体现出来
            computed是具有缓存的,只要计算属性依赖没有相应的进行数据更新,那么computed是直接从缓存中获取值的
    总结:在computed和watch方面,一个是计算,一个是观察,在语义上是有区别的,计算是通过变量计算来得出数据,而观察是一个特定的值

/*************************************************************************************************/
11.vue中data必须是一个函数
    对象为引用类似时,当重用组件时,由于数据对象都指向同一个data对象,当在一个组件中修改data时,其他重用组件的data会同时修改,而使用返回对象的函数
    由于每次都是一个新对象,引用地址不同,则不会出现这样的问题

/*************************************************************************************************/
12.vue组件通信
    父组件与子组件
        父组件传给子组件:子组件通过props方法接受数据
        子组件传给父组件:$emit方法传递参数
            子组件vm.$emit(eventName,arg)
            父组件vm.$on(event,fn)
                子组件
                    <template>
                        <div class="train-city">  
                            <span @click='select(`大连`)'>大连</span>  
                        </div>  
                    </template>  
                    <script>  
                        export default {  
                        name:'trainCity',  
                        methods:{  
                            select(val) {  
                                let data = {  
                                    cityname: val  
                                };  
                                this.$emit('showCityName',data);//select事件触发后，自动触发showCityName事件  
                                }  
                            }  
                        }
                    </script>
                父组件
                    <template>  
                        <trainCity @showCityName="updateCity" :index="goOrtoCity"></trainCity> //监听子组件的showCityName事件。  
                    <template>  
                    <script>
                        export default {  
                            name:'index',  
                            data () {  
                            return {  
                                toCity:"北京"  
                                }  
                            },  
                            methods:{  
                                updateCity(data){//触发子组件城市选择-选择城市的事件    
                                this.toCity = data.cityname;//改变了父组件的值  
                                console.log('toCity:'+this.toCity)        
                                }  
                            }  
                        }
                    </script>  
    非父组件,兄弟组件传值
        eventBus,创建一个事件中心,相当于中转站,可以用来传递事件和接受事件,也可以使用vuex
    props:
        通过一般属性实现父向子通信
        通过函数属性实现子向父通信
        缺点:隔代组件和兄弟组件通信比较麻烦
    vue自定义事件
         子组件vm.$emit(eventName,arg)
         缺点:只适合子向父通信
    消息订阅与发布
        优点:适合任何关系通信
    vuex

/*************************************************************************************************/
13.$nextTick是什么
    <div id="app">
        <div v-if="showTest" id="text">
            想要知道这段文字写的是什么
        </div>
        <button @lick="clickMe">点我试试看就能知道那段隐藏的文字写的是什么了</button>
    </div>
    ...
    data:{
        return {
            showTest:false
        }
    },
    methods:{
        clickMe() {
            this.showTest = true;
            var text = document.getElementById("text").innerHTML;
            alert(text) //  Uncaught TypeError: Cannot read property ‘innerHTML‘ of null
            //////
            改写
            this.$nextTick(() => {
                var text = document.getElementById("text").innerHTML;
                alert(text) // 这个时候可以
            })
        }
    }

/*************************************************************************************************/
14.vue中的ref是什么？
    https://www.cnblogs.com/agen-su/p/11388621.html
    ref被用来给元素或子元素注册引用信息,引用信息将会注册在父组件的$refs对象上,如果是普通dom元素上使用,引用指向dom元素
    如果用在子组件上,引用就指向组件实例
        <login ref="mylogin"></login>
        1获取dom元素 =>得应用普通dom元素上
        2获取子组件中的data =>应用在组件上this.$refs.mylogin.msg
        3调用子组件中的方法 this.$refs.mylogin.show()
        4子组件调用父组件的方法
    vm.$refs一个对象,持有已经注册过ref的所有子组件
    <input type="text" ref="input"> // ref:string是注册(绑定)
    console.log(this.$refs.input) //$refs(获取)所有子组件

/*************************************************************************************************/
15.vue中slot插槽
    https://www.cnblogs.com/loveyt/p/9946450.html
    默认插槽
    具名插槽
        插槽的默认内容
        编译作用域
        作用域插槽

/*************************************************************************************************/
16.vue双向绑定的原理
    vue是通过Object.defineProperty()来实现数据劫持
    实现方法:观察者模式Observer监听data的变化,当data有数据变化的时候通知观察者列表Dep(里面有与data变化对应的update函数)
            watcher负责向观察者列表里添加(订阅)对应的更新函数,Dep里的更新函数执行完成了之后将最新的值更新到view上

    <input type="text" id="in">
    输入值为:<span id="out"></span>
    const int = document.getElementById('in')
    const out = document.getElementById('out')
    var obj = {};
    Object.defineProperty(obj, 'msg', {
        enumerable: true,
        configurable:true,
        set(newVal) {
            out.innerHTML = newVal;
        }
    })
    int.addEventListener('input', function(e) {
        obj.msg = e.target.value;
    })
    // initState(初始化数据)、Observer(数据劫持-观察者)、Dep(订阅收集-发布者)、Watcher(订阅者-角色)、Compiler(编译器)

/*************************************************************************************************/
17.vuex详解
    https://segmentfault.com/a/1190000015782272

/*************************************************************************************************/
18.bfc格式化上下文
    块格式上下文是web页面的可视化css渲染的一部分,是块盒子的布局过程发生的区域,也是浮动元素与其他元素交互的区域
    下列方式会创建快格式上下文(常见)
        1根元素
        2浮动元素(元素的float不是none)
        3绝对定位元素(元素的position为absolute或fixed)
        4行内块元素(元素的display为inline-block)
        5.overflow值不为visible的元素
        6弹性元素(dispaly为flex或inline-flex元素的直接子元素)
        ...
    表现:比如一个元素float了,导致父级高度坍塌
    解决bfc-bug(创建一个新的bfc)
        1通常做法是设置父元素的overflow非visible的值
        2clear浮动
    应用
        1.实现左图右文效果
        2.创造bfc区块解决父元素高度坍塌问题
        3.自适应两栏布局
        4.防止margin重叠
    
/*************************************************************************************************/
19.html中title属性和alt属性的区别是
    alt属性和title属性的区别是前者是在图片无法加载的时候才会显示其值,而title是在图片正常加载鼠标划上去
    显示的值,虽然alt也有后者功能,但是只在低版的浏览器才支持

/*************************************************************************************************/
20.http状态码有什么用,分别代表着什么
    http状态码作用:
        http状态码的核心作用是web Server服务器用来告诉客户端,当前网页请求发送了什么事,或者说当前web服务器的响应状态
        通常判断http状态码分析当前web服务器运行状况
    常用的http状态码:
        200:服务器成功处理了请求
        301/302:301永久重定向,302临时重定向
        304:自上次请求后,请求的网页未修改过,服务器返回此响应,不会返回网页内容
        404:not found页面丢失(未找到资源)
        501:Internal Server Error服务器遇到一个错误,使其无法对请求提供服务
        1开头:(被接受，需要继续处理。)
        2开头:这一类型的状态码，代表请求已成功被服务器接收、理解、并接受
        3开头:(请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向)
        4开头:(请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。)
        5开头:(服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误)

/*************************************************************************************************/
21.什么是跨域,跨域解决方法
    为什么会出现跨域:
        出于浏览器的同源策略限制。同源策略是一种约定,它是浏览器最核心也是最基本的安全功能,如果缺少同源策略
        则浏览器的正常功能可能都会受到影响,同源策略会阻止一个域的javascript脚步和另一个域的内容进行交互
    什么是跨域:
        当一个请求url的协议,域名,端口,三者之间任意一个与当前页面url不同即为跨域
    非同源策略限制
        1.无法读取非同源网页的cookie,LocalStorage,IndexDB
        2.无法接触非同源网页的dom
        3.无法向非同源地址发送ajax请求
    跨域解决方法
        1设置document.domain解决无法读取非同源网页的cookie问题
            浏览器是通过document.domain属性来检查两个页面是否同源,因此只要设置相同的document.domain,两个页面就可以
            共享cookie(此方案仅限主域相同,子域不同的跨域应用场景)
        2.跨文档通信window.postMessage();
            解决问题
                1页面和其他新开窗口的数据传递
                2多窗口之间消息传递
                3页面与嵌套iframe消息传递
        3.JSONP
            JSONP是服务器与客户端跨源通信常用方法,最大特点简单适用兼容性好,缺点只支持get请求,不支持post请求

        4.CORS
            CORS是跨域资源分享,属于ajax请求的根本解决方法
                1.普通跨域请求,只需服务端设置Access-Control-Allow-Orign
                2.带cookie跨域请求:前后端都需要进行设置
                    前端:xrh.withCredentials = true字段判断是否带有cookie   
    

/*************************************************************************************************/
22.作用域,作用域链(重点)
    作用域
        变量作用域
            全局变量
                全局变量:作用域是全局的,在代码的任何地方都是有定义的
            局部变量
                局部变量:函数的参数和局部变量只在函数体内有定义,另外局部变量的优先级高于同名的全局变量
                    var num = 1; // 全局
                    function fun() {
                        var num = 2; // 局部(覆盖全局同名的变量)
                        return num;
                    }
                    fun() // 输出 2

                    if(true) { // 对于var来说，局部变量只能在函数内部声明，在其他区块(if for...)中声明，一律都是全局变量
                        var x = 5;
                    }
                    console.log(x) // 输出5

                    if(true) {
                        let x = 5; // let/const
                    }
                    console.log(x) // 报错

                    var x = function() {
                        console.log(a);
                    }
                    function y(f) {
                        var a = 2;
                        f();
                    }
                    y(x) // a is not defined

        函数作用域
            函数作用域:是指在函数内声明的所有变量在函数体内始终是可以见的,也就是说在函数体内声明之前就可以用了
                function func() {
                    console.log(num) // 输出undefined,而非报错,因为变量num在整个函数体内都是有定义的
                    var num = 1; // 声明num,在整个函数体func内有定义
                    console.log(num) // 输出1
                }
    作用域链
        函数对象和其他对象一样,可以通过属性访问,其中一个内部[[scope]],该内部属性包含了函数创建的作用域中对象集合
        这个集合被称为函数的作用域链,当一个函数创建后,它实际上保存了一个作用域链,并且作用域链会被创建此函数的作用域
        中可以访问的数据对象填充

/*************************************************************************************************/
23.拓展运算符和reset区别
    拓展运算符:
        function foo(a, b, c) {
            console.log(a); // 1
            console.log(b); // 2
            console.log(c); // 3
        }
        foo(...[1,2,3])
    reset参数
        function foo(..args) {
            console.log(args) // [1,2,3]
        }
        foo(1,2,3)
    arguments是什么
        arguments 是JavaScript里的一个内置对象,所有的函数都有属于自己的一个arguments对象，它包括了函所要调用的参数。object对象
    reset参数和arguments的区别:
        reset参数参数是获取剩余的参数 --- 真正数组
        arguments是所有的参数 --- 类数组 Array.from(arguments) || Array.prototype.slice.call(arguments)

/*************************************************************************************************/
24.观察者模式和发布订阅者区别
    观察者模式定义了对象之间一对多依赖,这样一来,当一个对象改变状态时,它的所有依赖者都会收到通知并自动更新,而发布订阅者者模式属于行为型
    模式，行为型模式关注的是对象之间通讯,观察者模式就是观察者和被观察者之间的通讯
    发布订阅模式需要一个事件调度中心,emit触发，而观察者模式当有个一依赖更新(notify)了，其他都会更新,
    vue中使用了发布订阅模式

/*************************************************************************************************/
26.cookie
    什么是cookie?
        cookie是存储在用户计算机上的小文件。它们旨在保护特定客户端和网站的适量数据,并且可以由web服务器或客户端浏览器访问
    cookie有什么作用?
        cookie的目的是帮助网站跟踪您的访问和活动
    cookie何时创建?
        将数据写入cookie通常是在加载新网页时完成的
    为什么使用cookie?
        存储一些数据信息例如登录信息
    cookie持续多久了?
        设置cookie到期时间,默认cookie是在当前浏览器窗口关闭时被销毁
    谁可以访问cookie?
        通过设置其根域控制可见性
    封装一个cookie方法
        function setCookie(){}
        function getCookie(){}
        function delCookie(){}
    httpOnly:true
    Secure:true
    domain:域名
    withCredentials: true
/*************************************************************************************************/
27.变量提升和函数提升
    var let const
        var v='Hello World';
        (function(){
            alert(v);
            var v='I love you';
        })()   // undefined

        var x = 1;
        console.log(x); // 1
        if (true) {
        var x = 2;
        console.log(x); //2
        }
        console.log(x);// 2
        同名的函数和变量函数优先级高于变量

        let const 不存在变量提升有块级作用域
        为什么const定义的对象是可以修改的?
            const p = {name:'yangyuan'}
            p变量中保存的是对象的指针，只要你不改变指针那么就不会报错。而修改对象的属性是不会改变指针的，所以是允许的

/*************************************************************************************************/
28.This(箭头函数中的this)
    箭头函数的this是继承外部函数的this，普通函数的是运行是this，箭头函数不能做构造函数,因为没有constructor
/*************************************************************************************************/
29.instanceof和typeof区别
    instanceof用于判断实例是否属于原型对象,返回值false/true
        function Person(){}
        var p = new Person()
        p instanceof Person // true
        var arr = new Array()
        arr instanceof Array
    typeof 通常判断内置数据类型,返回值为number,string,boolean,function,undefined,object
        typeOf '11' === string // true
        Object.prototype.toString.call([]) === '[object Array]' // true
        Object.prototype.toString.call({}) === '[object Object]' // true
/*************************************************************************************************/
30.in 和hasOwnproperty区别
    function Person() {
        this.age = '20'
    }
    Person.prototype.name = 'lisi'
    var p = new Person();
    in判断的是对象的所有属性,包括对象实例及其原型的属性(回向原型查找)
        'age' in p // true
        'name' in p // true
    hasOwnProperty则是判断对象实例是否具有某个属性
        p.hasOwnProperty('age') // true
        p.hasOwnProperty('name') // false
/*************************************************************************************************/
31.JS垃圾回收机制
    概念:
        一般来说没有被引用的对象就是垃圾,就是要被清楚,有一个例外如果几个对象引用形成一个环,互相引用,但根本访问不到它们,
        这几个对象也是垃圾,也要被清楚
        JavaScript 中的内存管理是自动执行的，而且是不可见的。垃圾回收机制会监视所有对象，并删除那些不可访问的对象
    内部算法
        标记清除
        - 垃圾回收器获取根并“标记”(记住)它们。
        - 然后它访问并“标记”所有来自它们的引用。
        - 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
        - 以此类推，直到有未访问的引用(可以从根访问)为止。
        - 除标记的对象外，所有对象都被删除。


/*************************************************************************************************/
32.es5构造函数和es6class区别
    super()

/*************************************************************************************************/
33.闭包
    闭包:就是能访问其他函数内部变量的函数(定义在一个函数内部的函数)
        function test(){ // 一个基本的闭包结构
            let a = 1;
            return function(){
                console.log(a)
            }
        }
        优点:
            1变量长期存在内存中
            2避免全局变量的污染
            3私有成员的存在
        确定:
            1常驻内存,有可能内存泄露
        特性:
            1函数套函数
            2内部函数可以直接使用外部函数局部变量或者参数
            3变量或参数不会被垃圾回收机制回收
    闭包作用:可以读取函数内部变量,让变量的值始终保持在内存中,不会被垃圾回收

/*************************************************************************************************/
34.js基本数据类型
    基本数据类型:String,Number,Boolean,Null,Undefined,Symbol
    对象类型:Array,Function,Object

/*************************************************************************************************/
35.css垂直居中
    方法很多暂不列举

/*************************************************************************************************/
36.盒子模型
    盒子的宽度 = width + padding-left + padding-right + border-left + border-right + margin-left + margein-right;
    盒子高度 = height + padding-top + padding-bottom + border-top + border-bottom + margin-top + margin-bottom;
    box-sizing
        content-box标注盒子模型 padding和border不被包含在定义的width和height之内  实际宽度 = 设置width + padding + border
        border-box ie盒子模型  padding和border被包含在应定义的width和height之内   实际宽度 = 设置的width
/*************************************************************************************************/
37.关于get和post区别
    已经在http.txt中描述过了
/*************************************************************************************************/
38.关于继承

/*************************************************************************************************/
39.js中各种位置,宽高
    clientHeight/clientWidth 获取可见宽高 padding+content
    offsetHeight和offsetWidth  元素border+padding+content,与超出滚动条无关
    clientTop和clientLeft  用来读取元素的border的宽度和高度的
    offsetLeft和offsetTop
        offsetParent指的是当前元素的离自己最近的具有定位的父级元素，如果从该元素向上寻找，找不到这样一个父级元素，
        那么当前元素的offsetParent就是body元素。offsetLeft和offsetTop指的是当前元素相对于其offsetParent左边
        和上边的距离，即当前元素的border到包含它的offsetParent的border的距离
    scrollWidth和scrollHeight 当元素内部内容超出其宽度和高度的时候，元素内部内容的实际宽度和高度(会受到滚动条宽高的影响)
    scrollTop和scrollLeft  元素中的内容超出其宽高的时候，元素被卷起的高度和宽度，没有滚动条即为0
    getBoundingClientRect 集合
        bottom: 608
        height: 543
        left: 0
        right: 120
        top: 65
        width: 120
        x: 0
        y: 65
/*************************************************************************************************/
40.事件循环机制

/*************************************************************************************************/
41.link标签和import标签区别
    1.种类:种类link是html的标签,@import是css提供的方式
    2.加载顺序,link在页面加载时被加载,@import在页面完全下载完之后在加载
    3.兼容性
    4.使用dom控制元素的不同,js控制页面样式时只能用link,@import不是dom可以控制的

/*************************************************************************************************/
42.transition和animation之间区别
    他们都是随时间改变元素的属性值，主要区别在于：transition需要触发一个事件才能改变属性，而animation不需要触发任何事件
    animation灵活,可以定义多个帧动画
        div{
            animation: name duration timing-function delay iteration-count direction
                animation-name: 规定需要绑定到选择器的keyframe名称
                animation-duration: 规定完成动画所花费的时间,以秒或毫秒计算
                animation-timing-function:规定在动画开始之前的延迟
                animation-iteration-count:规定动画应该播发的次数
                animation-direction:规定是否应该轮流反向播发
        }
    transition 是简单的from和to效果
        div{
            width:100px;
            transition:width 2s;
                transition:property duration timing-function delay;
                transition-property:规定设置过度效果的css属性名称
                transition-duration:规定完成过度效果需要多少秒或毫秒
                transition-timing-function:规定速度效果的速度曲线
                transition-delay:定义过度效果何时开始 
        }
    

/*************************************************************************************************/
43.语义化
    1即使在没有CSS样式的条件下，也能很好地呈现出内容结构、代码结构；
    2语义化HTML会使HTML结构变的清晰，有利于维护代码和添加样式；
    3方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
    4提升搜索引擎优化(SEO)的效果。和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
    5便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
    6通常语义化HTML会使代码变的更少，使页面加载更快

/*************************************************************************************************/
44.null和undefined区别
    null和undefined基本同义
    null
        表示没有对象,即该处不应该有值
        1作为函数的参数,表示该函数的参数不是对象
        2作为对象原型链的终点
    undefined表示缺少值,即此处应该有值,但没有定义
        1定义了形参,没有传实参,显示Undefined
        2对象属性名不存在时,显示Undefined
        3函数没有写返回值,即没有写return,拿到的是undefined
        4写了return,但没有赋值,拿到的是undefined
    null和undefined转换成number数类型
        null默认转成0
        undefined默认转成NaN

/*************************************************************************************************/
45.setState机制
    setState异步更新机制
    setState调用会引起4个生命周期
    setState是异步的,如果相邻的状态会被更新,会被合并
    setState只在合成事件和钩子函数中是'异步'的,在原生事件和setTimeout中都是同步的

/*************************************************************************************************/
46.diff算法
    diff算法的作用是用来计算出Virtual DOM中被改变的部分,然后针对该部分进行原生DOM操作,而不用重新渲染整个页面
    diff算法有三大策略
        1.Tree Diff
        2.Component Diff
        3.Element Diff
    三种策略的执行顺序也是顺序依次执行
        Tree Diff是对树每一层进行遍历,找出不同  
        Component Diff是数据层面的差异比较
            1.如果都是同一类型的组件(即:两节点是同一个组件类的两个不同实例,比如<div id="before"></div>与<div id="after"></div>)
            按着原策略继续比较Virtual DOM树即可
            2.如果出现不是同一类型的组件,则将该组件判断为dirty Component,从而替换整个组件下的所有子节点
        Element Diff真实的DOM渲染,结构差异的比较
            1当节点属于同一层级时，diff提供了3种节点操作，分别为INSERT_MARKUP(插入)，MOVE_EXISTING(移动),REMOVE_NODE(删除)。


/*************************************************************************************************/
47.key的作用
    key的作用是为了diff算法执行时更快的找到对应的节点,提高diff速度
    key具有唯一性

/*************************************************************************************************/
48.react阻止事件冒泡
    https://blog.csdn.net/w799766/article/details/82591372   
    1.在没有涉及到原生事件注册只有react事件时,用e.stopPropagation()阻止冒泡
    2.当document.addEventListener注册了原生事件后,用e.stopPropagation()是不能阻止与document之间的冒泡的,这时候
    需要用到e.nativeEvent.stoplmmedatePropagation()方法
    3.阻止合成事件与非合成事件(除了document)之间的冒泡,以上两种方式都不适用,需要用e.target判断
/*************************************************************************************************/
49.redux有什么用,什么是redux,为什么会出现
    为什么用redux
        因为对于react来说,同级组件之间的通信尤为麻烦,或者太麻烦,所以我们把所有需要多个组件使用的state拿出来,整合到顶部容器
        ,进行分发
    react-router-redux
        顶层容器Provider,里面有很多小盒子(Component),小盒子之间不能通信,每个盒子都有一个壳子,state穿不过去,于是就有connect
        来进行连接state和Component
    Provider作为顶层容器接受store作为参数,进行state分发,在这里,state并不是清晰的设置一个对象,所有的共享数据都在里面,而是由多个
    reducer组成,每个reducer有一个小小的state,多个小的state就组成了一个大的state，Provider在所有的router最外层
    connect存在于每个需要共享的数据的组件里,connect方法接受两个参数
        mapStateToProps:mapStateToProps接受state和当前组件的props作为参数
        mapDispatchToProps:它接受dispatch作为参数,将当前组件会用到的dispatch(action)映射到当前组件的事件的回调函数上,换个
        名字注入到props里面,然后在组件内部调用
/*************************************************************************************************/
50.action,reducer,store以及三者之间的关系
    action:当view需要发起行为时,需要在当前位置出发action,即store.dispatch(addNote())
    reducer:当store收到action时,必须给出一个新的state,这样view才会发生变化,而这中state的计算过程就叫做reducer,而reducer方法是
    由store.dispatch方法来自动执行的,为此store需要知道reducer函数,做法就是生成store的时候将reducer传入createStore方法


/*************************************************************************************************/
51.middlewares中间件
    applyMiddlewares它是redux原生方法,作用是将所有中间件组成一个数组,一次执行

/*************************************************************************************************/
52.redux-trunk
    import { applyMiddleware, createStore } from 'redux';
    const store = createStore(reducer, applyMiddleware(thunk, logger))
    让action接受一个返回函数的action creator如果这个action creator返回的是一个函数,就执行它,如果不是就按照原来的next(action)执行
    export function addCount() {
        return {type :ADD_COUNT}
    }
    export function addCountAsync() {
        return dispatch => {
            setTimeout(() => {
                dispatch(addCount())
            }, 2000)
        }
    }

/*************************************************************************************************/
53.connect如果连接react和redux
    https://www.cnblogs.com/passkey/p/9910760.html
    首先在最外层容器中,把所有内容包裹在Provider组件中,将之前创建的store作为prop传给Provider
    Provider内的任何一个组件,如果需要使用state中的数据,就必须被connect过
/*************************************************************************************************/
54.mapStateToProps,mapDispatchToProps
    connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])
    mapStateToProps(state, ownProps): stateProps
        这个函数允许我们将store中的数据作为props绑定到组件上,这个函数的第一个参数就是redux的store,我们从中摘取了count属性
        因为返回了具有count属性的对象,所以组件会有名为count的props字段
        const mapStateToProps = (state) => {
            return state.count;
        }
        函数的第二个参数ownProps是组件组件的props,比如在store中维护了一个用户列表,而你只关心一个用户
        const mapStateToProps = (state, ownProps) => {
            return user: _find(state.userList, {id: ownProps.userId})
        }
        当state变化,或者ownProps变化的时候,mapStateToProps都会被调用,计算出一个新的stateProps

    mapDispatchToProps
        mapDispatchToProps它的功能是,将action作为props绑定到组件上
        const mapDispatchToProps = (dispatch, ownProps) => {
            return {
                increase: (...args) => dispatch(actions.increase(...args)),
                decrease: (...args) => dispatch(actions.defineProperty(...args))
            }
        }
        调用actions.increase方法返回了具有increase属性和decrease的对象,这两个属性也成为props
        调用actions.increase()只能得到一个action对象{type:'INCREASE'},需要出发这个action必须在store上调用dispatch方法,
        dispatch是mapDispatchToProps第一个参数
        同样ownProps变化也好生成一个新的
    bindActionCreators
        import {bindActionCreators} from 'redux';
        const mapDispatchToProps = (dispatch, ownProps) => {
        return bindActionCreators({
            increase: action.increase,
            decrease: action.decrease
        });
        }
/*************************************************************************************************/
55.react-router

/*************************************************************************************************/
56.e.target和e.currentTarget的区别
    let ul = document.querySelectorAll('ul')[0];
    let aLi = document.querySelectorAll('li')
    ul.addEventListener('click', function(e) {
        let oLi1 = e.target;
        let oLi2 = e.currentTarget
        console.log(oLi1) // 被点击的li
        console.log(oLi2) // ul
    })

/*************************************************************************************************/
57.堆/栈区别
    概念
        栈会自动分配内存空间,会自动释放。堆动态分配内存,大小不定也不会自动释放
    数据类型表现形式
        基本类型:简单的数据段,存放在栈内存中,占据固定的大小空间，存取速度都很快，先进后出，类似羽毛球桶，先放进去的羽毛球，要想拿出来，必须先把后放进去的羽毛球拿出来
        引用类型:指那些可能由多个值构成的对象,保存在堆内存中，堆就像一个仓库，随机存，直接取，没有像栈这么麻烦，引用值是将其地址存放在栈中，将值存放在对内存中
    存储方式
        栈的存储方式是值的拷贝，复制了是会有一个新的值
        堆的存储方式是地址放在栈中，值放在内存中，复制的是地址，新的值还是地址的引用



/*************************************************************************************************/
58.webpack优化
    https://segmentfault.com/a/1190000015048417?utm_source=index-hottest
    优化开发体验
        1优化构建速度
            1缩小文件搜索范围
            2使用DLLPlugin
            3Happypack 只是作用在 loader 上，使用多个进程同时对文件进行编译
        2优化使用体验,通过自动化手段完成一些重复的工作，让我们专注于解决问题本身
            1使用自动刷新
            2开启模块热替换
    优化输出质量
        优化输出质量的目的是为了给用户呈现体验更好的网页，例如减少首屏加载时间、提升性能流畅度等。 这至关重要，因为在互联网行业竞争日益激烈的今天，这可能关系到你的产品的生死
            区分环境
            压缩代码
            CDN 加速
            使用 Tree Shaking
            提取公共代码
            按需加载
        提升流畅度，也就是提升代码性能
            使用 Prepack
            开启 Scope Hoisting
    优化 loader 配置
    优化 resolve.modules 配置
    优化 resolve.mainFields 配置
    优化 resolve.alias 配置
    优化 resolve.extensions 配置
    优化 module.noParse 配置
    
/*************************************************************************************************/
59.EventLoop
console.log('打印'+1);
setTimeout(function(){
    console.log('打印'+2);
})
new Promise(function(resolve,reject){
        console.log('打印'+3);
      }).then(
  console.log('打印'+4));;
// console.log('打印1')
// console.log('打印3')
// console.log('打印4')
// console.log('打印2')

promise的构造函数部分是同步的,then函数会放在微任务那里

/*************************************************************************************************/
60.vue defineProperty/proxy区别
    vue是不能运行在低版本浏览器中的,因为低版本浏览器不支持defineProperty/propx的
    区别
        defineProperty只能监听某个属性不能全对象监听,proxy不用设置具体属性
    Vue.$set()解决data数据不能响应更新到视图中
        <p @click="add">{{obj.d}}</p>
        <p @click="add">{{obj.e}}</p>

        export default {
            data(){
                return {
                    obj:{}
                }
            },
            mounted(){
                this.obj = {d:0}; 动态新增的属性并不能相应,这个时候需要$set()方法解决
                this.obj.e = 0;
            },
            methods:{ // 
                add()  {
                    this.obj.d = this.obj.d + 1; // 并不会响应,因为defineProperty不能深层次的监听
                    // 解决
                    this.$set(this.obj, 'd',value)
                }
            }
        }
    

/*************************************************************************************************/
61.常见的兼容性问题有哪些
    1.不同浏览器的标签默认的外补丁和内补丁不同
        问题症状:随便写几个标签,不加样式控制情况下,各自margin和padding差异较大
        解决方案:css里*{margin:0;padding:0;},一般重置样式文件
    2.盒子模型
        box-sizing:content-box||border-box 宽高计算的方式不同
    3.ie事件监听和标准dom事件监听
        ie8之后addEventListener(eventName,function,false)
        ie8之前attachEvent(eventName,function)

/*************************************************************************************************/
62.new Set()/new Map()使用

/*************************************************************************************************/
63.箭头函数和普通函数区别?能不能作为构造函数
    1.语法更加简洁,清晰
    2.箭头函数不会创建自己的this
    3.箭头函数继承而来的this指向永远不变
    4.call/apply/bind无法改变箭头函数中this指向
    5.箭头函数不能作为构造函数使用
    6.箭头函数没有自己的arguments
    7.箭头函数没有原型prototype，constructor
    8.箭头函数不能做generator函数,不能使用yeild关键字

/*************************************************************************************************/
64.虚拟DOM的好处?
    减少了同一时间内的页面多处内容修改所触发的浏览器reflow和repaint的次数，可能把多个不同的DOM操作集中减少到了几次甚至一次
    ，优化了触发浏览器reflow和repaint的次数

/*************************************************************************************************/
65.h5适配 rem/em/pt/px区别