/*************************************************************************************************/
1.new 操作符具体做了什么？
var Fn = function() {}
var fnObj = new Fn();

1创建一个空对象
var obj = new Object();
2设置原型链
obj._proto_ = Fn.prototype;
3让Fn的this指向obj,并执行Fn的函数体
var result = fn.call(obj)
4判断Fn的返回值类型,如果是值类型,返回obj,如果是引用类型,就返回这个引用类型的对象
if(typeof result === 'object) {
    fnObj = result;
} else {
    fnObj = obj;
}

/*************************************************************************************************/
2.原型链,原型,构造函数之间的关系总结
Function Person {}
const p1=new Person()
p1.prototype是undefined
实例p1上面是没有prototype而是通过__proto__访问到Person.prototype

p1.construct=Person
p1.__proto__=Person.prototype
Person.prototype.__proto__=Object.prototype
Object.prototype.__proto__=null

一切底层对象上的原型的原型链等于对象的原型
Function.prototype__proto__=Object.prototype
Array.prototype__proto__=Object.prototype

一切底层对象原型链等于函数的原型
Object.__proto__=Function.prototype
Array.__proto__=Function.prototype

一切底层对象上的构造函数等于构造器函数，
对象上构造器来自Function
Array.construct=Function
String.construct=Function
Object.construct=Function
cons arr=[1,2]
art.construct = Array

一切对象上原型的构造函数等于自己本身
Array.prototype.construct=Array
Object.prototype.construct=Object

/*************************************************************************************************/
3.浏览器的解析过程
1输入地址
2浏览器查找域名的ip地址
    首先查看本地的hosts文件->本地的dns服务器->域服务器,查找到对应的ip地址,并且缓存
3浏览器向web服务器发送一个http请求
    三次握手建立连接
4建立连接之后
    会相应一些状态码200,304,500根据状态码做对应的处理
5拿到数据后
    首先解析html，构建dom树->构建render->树布局render->树绘制render树

    解析过程中,浏览器首先会解析html文件构建dom树，然后解析css文件构建的渲染树，等到渲染树构建完成
    浏览器开始布局渲染树并将绘制到屏幕上

    浏览器自上而下执行,过程中如遇到css,img等,请求是异步的

    当文档加载过程中遇到js文件,html文档会挂起来渲染的线程,不仅要等待文档中js文件加载完毕，还有等待
    解析执行完毕,才可以恢复html文档渲染线程,因为js有可能修改dom,所以在编写代码尽可能吧js写在底部
    等html主体和css加载完之后在进行加载js

/*************************************************************************************************/
4.什么是回流，什么是重绘，有什么区别?
当render tree中的一部分因为元素规模尺寸,布局,隐藏等改变而需要重新构建,这就称为----回流
    (添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变---回流)

当render tree中的一些元素需要更新属性,而这些属性只是影响外观,风格,比如background-color称之为----重绘

区别
    回流必将引起重绘,而重绘不一定引起回流
优化
    比如改变样式的时候，不去改变他们每个的样式，而是直接改变className

/*************************************************************************************************/
http和https区别
    http缺点
        1通信使用明文,内容可能被窃听
        2不验证通信方身份,有可能遭遇伪装
        3无法证明报文完整性,有可能遭篡改(运营商劫持)
    http = tcp + ip
    https = ssl + tcp + ip

ssl
    ssl可以分为两层
        ssl记录协议:它建立在可靠的传输记录协议之上(tcp),为高层次协议提供数据封装,压缩,加密等基本功能支持
        ssl握手协议:它建立在ssl记录协议之上,用于在实际的数据传输开始之前,通讯双方进行身份认证,协商加密算法、交换密匙

对称密匙
    对称密匙加密,又称私钥加密,即信息的发送方和接受方用同一个密匙去加密和解密数据.它最大的优势是加/解密速度快,适合于
    大数据量进行加密,但密匙管理困难

非对称加密
    又称公匙加密,它需要使用一对密匙来分别完成加密和解密,一个公开发布,即公开密匙,另一由用户自己密目保存,即私用密匙。信息发送者
    用公开密匙去加密,而信息接受者则用私用密匙去解密

https工作原理
    1客户端发起https请求
        用户在浏览里输入一个https网站,然后连接到server的443端口
    2服务端的配置
        采用https协议的服务器必须要与一套数字证书,可以自己制作,也可以向组织申请,区别就是自己在颁发的证书需要客户端验证通过
    3传送证书
        这个证书其实公匙,只是包含了很多信息,如证书的颁发机构,过期时间等等
    4客户端解析证书
        这部分是有客户端tls来完成的,首先会验证公匙是否有效,比如颁发机构,过期时间,如果发现异常则弹出警告
    5传送加密信息
        这部分传送的是用证书加密后随机值(私钥),目的就是让服务端得到这个随机值,以后客户端和服务端的通信就可以通过这个随机值来进行加密
    6服务端解密信息
        服务端用私钥解密后,得到了客户端传过来随机值(私钥),然后把内容通过该值进行对称加密
    7传输加密后的信息
        这部分信息是服务端用私钥加密后的信息,可以在客户端还原
    8客户端解密信息
        客户端用之前生成私钥解密服务端传过来的信息,于是获取了解密后内容

区别
    https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

/*************************************************************************************************/
TCP-三次握手和四次挥手简单理解
三次握手
    原理
        1发送端首先发送一个带有SYN标志地数据包给接收方
        2接收方接受后,回传一个带有SYN/ACK标志的数据包传递确认信息,表示收到了
        3最后,发送方再回传一个带有ACK标志的数据包,代表我知道了,表示握手结束
    通俗说话
        Client:嘿,李四,是我,听到了吗?
        Server:我听到了,你能听到我的吗?
        Client:好的,我们互相都能听到对方的话,我们通信可以开始了
四次挥手
    原理
        1.第一次挥手:Client发送一个FIN,用来关闭Client到Server的数据传递,Client进入FIN_WAIT_1状态
        2.第二次挥手:Server收到FIN后,发送一个ACK给给Client,确认序号为+1,Server进入CLOSE_WAIT状态
        3.第三次挥手:Server发送一个FIN,用来关闭Server到Client的数据传递,Server进入LAST_ACK状态
        4第四次挥手:Client收到FIN后,Client进入TIME_WAIT状态,接着发送一个ACK给Server,确认序号为+1,Server进入CLOSE状态
    通俗说话
        Client:我所有东西都说完了
        Server:我已经全部听到了,但是等等我,我还没有说完
        Server:好了,我已经说完了
        Client:好的,那我们的通信结束
