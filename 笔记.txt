/*************************************************************************************************/
1.new 操作符具体做了什么？
var Fn = function() {}
var fnObj = new Fn();

1创建一个空对象
var obj = new Object();
2设置原型链
obj._proto_ = Fn.prototype;
3让Fn的this指向obj,并执行Fn的函数体
var result = fn.call(obj)
4判断Fn的返回值类型,如果是值类型,返回obj,如果是引用类型,就返回这个引用类型的对象
if(typeof result === 'object) {
    fnObj = result;
} else {
    fnObj = obj;
}

/*************************************************************************************************/
2.原型链,原型,构造函数之间的关系总结
Function Person {}
const p1=new Person()
p1.prototype是undefined
实例p1上面是没有prototype而是通过__proto__访问到Person.prototype

p1.construct=Person
p1.__proto__=Person.prototype
Person.prototype.__proto__=Object.prototype
Object.prototype.__proto__=null

一切底层对象上的原型的原型链等于对象的原型
Function.prototype__proto__=Object.prototype
Array.prototype__proto__=Object.prototype

一切底层对象原型链等于函数的原型
Object.__proto__=Function.prototype
Array.__proto__=Function.prototype

一切底层对象上的构造函数等于构造器函数，
对象上构造器来自Function
Array.construct=Function
String.construct=Function
Object.construct=Function
cons arr=[1,2]
art.construct = Array

一切对象上原型的构造函数等于自己本身
Array.prototype.construct=Array
Object.prototype.construct=Object

/*************************************************************************************************/
3.浏览器的解析过程
1输入地址
2浏览器查找域名的ip地址
    首先查看本地的hosts文件->本地的dns服务器->域服务器,查找到对应的ip地址,并且缓存
3浏览器向web服务器发送一个http请求
    三次握手建立连接
4建立连接之后
    会相应一些状态码200,304,500根据状态码做对应的处理
5拿到数据后
    首先解析html，构建dom树->构建render->树布局render->树绘制render树

    解析过程中,浏览器首先会解析html文件构建dom树，然后解析css文件构建的渲染树，等到渲染树构建完成
    浏览器开始布局渲染树并将绘制到屏幕上

    浏览器自上而下执行,过程中如遇到css,img等,请求是异步的

    当文档加载过程中遇到js文件,html文档会挂起来渲染的线程,不仅要等待文档中js文件加载完毕，还有等待
    解析执行完毕,才可以恢复html文档渲染线程,因为js有可能修改dom,所以在编写代码尽可能吧js写在底部
    等html主体和css加载完之后在进行加载js

/*************************************************************************************************/
4.什么是回流，什么是重绘，有什么区别?
当render tree中的一部分因为元素规模尺寸,布局,隐藏等改变而需要重新构建,这就称为----回流
    (添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变---回流)

当render tree中的一些元素需要更新属性,而这些属性只是影响外观,风格,比如background-color称之为----重绘

区别
    回流必将引起重绘,而重绘不一定引起回流
优化
    比如改变样式的时候，不去改变他们每个的样式，而是直接改变className

/*************************************************************************************************/
5.http和https区别
    http缺点
        1通信使用明文,内容可能被窃听
        2不验证通信方身份,有可能遭遇伪装
        3无法证明报文完整性,有可能遭篡改(运营商劫持)
    http = tcp + ip
    https = ssl + tcp + ip

ssl
    ssl可以分为两层
        ssl记录协议:它建立在可靠的传输记录协议之上(tcp),为高层次协议提供数据封装,压缩,加密等基本功能支持
        ssl握手协议:它建立在ssl记录协议之上,用于在实际的数据传输开始之前,通讯双方进行身份认证,协商加密算法、交换密匙

对称密匙
    对称密匙加密,又称私钥加密,即信息的发送方和接受方用同一个密匙去加密和解密数据.它最大的优势是加/解密速度快,适合于
    大数据量进行加密,但密匙管理困难

非对称加密
    又称公匙加密,它需要使用一对密匙来分别完成加密和解密,一个公开发布,即公开密匙,另一由用户自己密目保存,即私用密匙。信息发送者
    用公开密匙去加密,而信息接受者则用私用密匙去解密

https工作原理
    1客户端发起https请求
        用户在浏览里输入一个https网站,然后连接到server的443端口
    2服务端的配置
        采用https协议的服务器必须要与一套数字证书,可以自己制作,也可以向组织申请,区别就是自己在颁发的证书需要客户端验证通过
    3传送证书
        这个证书其实公匙,只是包含了很多信息,如证书的颁发机构,过期时间等等
    4客户端解析证书
        这部分是有客户端tls来完成的,首先会验证公匙是否有效,比如颁发机构,过期时间,如果发现异常则弹出警告
    5传送加密信息
        这部分传送的是用证书加密后随机值(私钥),目的就是让服务端得到这个随机值,以后客户端和服务端的通信就可以通过这个随机值来进行加密
    6服务端解密信息
        服务端用私钥解密后,得到了客户端传过来随机值(私钥),然后把内容通过该值进行对称加密
    7传输加密后的信息
        这部分信息是服务端用私钥加密后的信息,可以在客户端还原
    8客户端解密信息
        客户端用之前生成私钥解密服务端传过来的信息,于是获取了解密后内容

区别
    https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

/*************************************************************************************************/
6.TCP-三次握手和四次挥手简单理解
三次握手
    原理
        1发送端首先发送一个带有SYN标志地数据包给接收方
        2接收方接受后,回传一个带有SYN/ACK标志的数据包传递确认信息,表示收到了
        3最后,发送方再回传一个带有ACK标志的数据包,代表我知道了,表示握手结束
    通俗说话
        Client:嘿,李四,是我,听到了吗?
        Server:我听到了,你能听到我的吗?
        Client:好的,我们互相都能听到对方的话,我们通信可以开始了
四次挥手
    原理
        1.第一次挥手:Client发送一个FIN,用来关闭Client到Server的数据传递,Client进入FIN_WAIT_1状态
        2.第二次挥手:Server收到FIN后,发送一个ACK给给Client,确认序号为+1,Server进入CLOSE_WAIT状态
        3.第三次挥手:Server发送一个FIN,用来关闭Server到Client的数据传递,Server进入LAST_ACK状态
        4第四次挥手:Client收到FIN后,Client进入TIME_WAIT状态,接着发送一个ACK给Server,确认序号为+1,Server进入CLOSE状态
    通俗说话
        Client:我所有东西都说完了
        Server:我已经全部听到了,但是等等我,我还没有说完
        Server:好了,我已经说完了
        Client:好的,那我们的通信结束

/*************************************************************************************************/
7.事件的各个阶段
    捕获阶段-->目标阶段-->冒泡阶段
    document-->target-->document
    addEventList第三个参数设置true和false的区别已经非常清晰了
    true表示该元素在事件的捕获阶段(由外往内传递)响应事件
    false表示该元素在事件的冒泡阶段(由内向外传递)响应事件

/*************************************************************************************************/
8.web性能优化
    1压缩html/css/js使用Brotli比Gzip压缩效果更好,更快 chrome下 response header content-encoding:br
    2内嵌js一定要放在link css加载的前面,防止js阻塞css
    3使用框架代码和polyfill文件可以直接引用script标签不必打包到webpack中,利用缓存
    4使用静态域名js/css/img突破同域并发限制请求,并可以请求资源没带cookie请求
    5自定义ui,少用第三方ui库
    6使用阿里nginx模块nginx-http-concat做到多个文件合并一次请求
    7图片使用webp和图片可以根据尺寸返回
    8使用serviceWorker离线缓存
    9使用css:-webkit-touch-action:manipulation;touch-action:manipulation来解决300ms延迟代替fastClick.js
    10使用料加载技术优化图片加载
    11使用https和http2.0加载网页,使用tcp多路复用,网页更加安全
    12可以使用nodejs输出接口数据,前端直接拿到window上的变量数据,做出了避免客户端白屏问题 window._nuxt_ = <%-JSON.stringify(data)%>
    13preload/prefatch/dns-prefetch预加载/下个页面加载/dns与解析
    14async/defer延迟加载或异步加载
    15避免浏览器dom引起大量的重排和回流
    16服务端配置Cache-control max-age = 2592000
    17利用LocalStorage缓存接口数据,根据时间半小时/1天,减少服务器请求,定时清理

/*************************************************************************************************/
9.vue生命周期
    beforeCreate
        实例最近刚刚创建,元素dom和数据都还没有初始化
    Create
        数据data已经完成初始化,方法也可以调用,但dom未渲染,dom未挂载
    beforeMount
        dom未完成挂载,数据也为初始化完成,数据双向绑定显示{{}},这是因为vue采用虚拟dom技术
    mounted
        数据和dom都完成挂载,在删一个周期站位的数据给渲染进去,请求一般在这个位置
    beforeUpdate
        只要是页面数据改变了都会触发,数据更新之前，页面数据还是原来的数据,当你请求一个赋值一个数据时候会执行这个周期
    updated
        主要页面数据改变了都会触发,数据更新完毕,页面的数据是更新完成的,beforeUpdate和updated谨慎使用,因为页面更新数据都会触发
    beforeDestroy
        组件销毁前执行,清除定时器
    destroyed
        组件销毁,还是可以使用data数据和methods里的方法

/*************************************************************************************************/
10.computed、watch、methods的区别
https://www.cnblogs.com/widgetbox/p/8954162.html
    computed
        当页面中有某些数据依赖其他数据进行变动的时候,可以使用计算属性,需要注意的是,就算在data中没有声明出要计算的变量,也可以写入
        计算属性默认只有getter,可以在需要的时候设置setter
            computed:{
                fullName:{
                    get:function() {
                        return this.firstName + this.lastName
                    },
                    set:function() {
                        // ...
                    }
                }
            }
    watch
        watch和computed很相似,watch用于观察和监听页面上的vue实例,当然大部分我们都会使用computed,数据开变化同时
        进行异步或者开销比较大,选择watch,watch为一个对象,键是需要观察的表达式,值是对应的回调函数,值也可以是方法名,
        如果data中没有相应的属性,是不能watch,这点和computed不一样
            watch: {
                firstName: function(val) {
                    this.function = val + '' + this.lastName
                },
                lastName:function(val) {
                    this.function = this.firstName + '' + val
                }
            }
    methods
        方法,只要调用就好重新执行一次,相应的有一些触发条件,在某些时候methods和computed看不出茶杯,运算量比较大就会体现出来
        computed是具有缓存的,只要计算属性依赖没有相应的进行数据更新,那么computed是直接从缓存中获取值的
总结:在computed和watch方面,一个是计算,一个是观察,在语义上是有区别的,计算是通过变量计算来得出数据,而观察是一个特定的值

/*************************************************************************************************/
11.vue中data必须是一个函数
    对象为引用类似时,当重用组件时,由于数据对象都指向同一个data对象,当在一个组件中修改data时,其他重用组件的data会同时修改,而使用返回对象的函数
    由于每次都是一个新对象,引用地址不同,则不会出现这样的问题

/*************************************************************************************************/
12.vue组件通信
    父组件与子组件
        父组件传给子组件:子组件通过props方法接受数据
        子组件传给父组件:$emit方法传递参数
    非父组件,兄弟组件传值
        eventBus,创建一个事件中心,相当于中转站,可以用来传递事件和接受事件,也可以使用vuex

/*************************************************************************************************/
13.$nextTick是什么
    <div id="app">
        <div v-if="showTest" id="text">
            想要知道这段文字写的是什么
        </div>
        <button @lick="clickMe">点我试试看就能知道那段隐藏的文字写的是什么了</button>
    </div>
    ...
    data:{
        return {
            showTest:false
        }
    },
    methods:{
        clickMe() {
            this.showTest = true;
            var text = document.getElementById("text").innerHTML;
            alert(text) //  Uncaught TypeError: Cannot read property ‘innerHTML‘ of null
            //////
            改写
            this.$nextTick(() => {
                var text = document.getElementById("text").innerHTML;
                alert(text) // 这个时候可以
            })
        }
    }

/*************************************************************************************************/
14.vue中的ref是什么？