/*************************************************************************************************/
1.CommonJs.required.amd.cmd,import区别?

/*************************************************************************************************/
2.合成层怎么触发，怎么分的

/*************************************************************************************************/
3.CSS 定位方式， sticky 的使用场景
    position:static|relative|absolute|fixed|sticky
        sticky:粘性定位
        应用场景:滚动头部固定定位
        使用方式{
            position:sticky;
            top:0
        }
        生效规则,必须制定top,right,bottom,left其中一个阈值,才可以使粘性定位生效

/*************************************************************************************************/
4.script 标签的 async 和 defer 属性

/*************************************************************************************************/
5.向一个 DOM 后面插入节点怎么做

/*************************************************************************************************/
6.浏览器缓存

/*************************************************************************************************/
7.ContentType 有哪些，formData 里面是什么结构(https://www.cnblogs.com/xiaozong/p/5732332.html)
    1.application/x-www-form-urlencoded
        POST http://www.example.com HTTP/1.1
        Content-Type: application/x-www-form-urlencoded;charset=uft-8;
        title=测试&sub=12
    
    2.multipart/form-data(一般用户文件上传)
        POST http://www.example.com HTTP/1.1
        Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA
        
        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA
        Content-Disposition: form-data; name="text"
        
        title
        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA
        Content-Disposition: form-data; name="file"; filename="chrome.png"
        Content-Type: image/png
        
        PNG ... content of chrome.png ...
        ------WebKitFormBoundaryrGKCBY7qhFd3TrwA--
    3.application/json
        POST http://www.example.com HTTP/1.1
        Content-Type: application/json;charset=utf-8
        {"title":"test","sub":[1,2,3]}
/*************************************************************************************************/
8.在上家公司遇到了什么问题，怎么解决的，技术和非技术都可以说说

/*************************************************************************************************/
9.base64 是什么
    Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。
    Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读

/*************************************************************************************************/
10.for in 与Object.keys()的区别
    funcition Person(name,age) {
        this.name = name;
        this.age = age;
    }

    Person.prototype = {
        sex:'男'
    }

    var man = new Person('张三', 18);

    console.log(Object.keys(man)) // ['name','age']

    for(var key in man) {
        console.log(key) // name age sex
    }

/*************************************************************************************************/
11.Promise 有哪些方法，都是做什么的
    Promise.all(iterable)
        function promise1 () {
            return new Promise(resolve => {
                console.log('promise1 start');
                setTimeout(() => {
                console.log('promise1 over');
                resolve();
                }, 100);
            })
        }
        function promise2 () {
            return new Promise(resolve => {
                console.log('promise2 start');
                setTimeout(() => {
                console.log('promise2 over');
                resolve();
                }, 90);
            })
        }

        Promise.all([promise1(), promise2()]) // promise1 start -> promise2 start -> promise2 over -> promise1 over
        all()里面接受promise对象,只有里面所有的resolved才会整个结果resolved
        all()是并行执行的,all()获得成功结果数组里面的数据顺序和all()接收到数据顺序是一致的,不会因为相应顺序而改变
    Promise.race(iterable)
        方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝
        返回值:一个待定的 Promise 只要给定的迭代中的一个promise解决或拒绝，就采用第一个promise的值作为它的值，从而异步地解析或拒绝（一旦堆栈为空
        var p1 = new Promise(function(resolve, reject) { 
            setTimeout(resolve, 500, "one"); 
        });
        var p2 = new Promise(function(resolve, reject) { 
            setTimeout(resolve, 100, "two"); 
        });

        Promise.race([p1, p2]).then(function(value) {
        console.log(value); // "two"
        // 两个都完成，但 p2 更快
        });

        var p3 = new Promise(function(resolve, reject) { 
            setTimeout(resolve, 100, "three");
        });
        var p4 = new Promise(function(resolve, reject) { 
            setTimeout(reject, 500, "four"); 
        });

        Promise.race([p3, p4]).then(function(value) {
        console.log(value); // "three"
        // p3 更快，所以它完成了              
        }, function(reason) {
        // 未被调用
        });

        var p5 = new Promise(function(resolve, reject) { 
            setTimeout(resolve, 500, "five"); 
        });
        var p6 = new Promise(function(resolve, reject) { 
            setTimeout(reject, 100, "six");
        });

        Promise.race([p5, p6]).then(function(value) {
        // 未被调用             
        }, function(reason) {
        console.log(reason); // "six"
        // p6 更快，所以它失败了
        });

/*************************************************************************************************/
12.BFC 的原理和使用场景

/*************************************************************************************************/
13.如何并发执行 async

/*************************************************************************************************/
14.几道看输出的题目，考察变量声明提升，暂时性死区，原型链

/*************************************************************************************************/
15.显示器刷新率与浏览器帧率

/*************************************************************************************************/
16.requestanimationframe setTimeout区别(https://www.cnblogs.com/codejoker/p/10503251.html)
    requestanimationframe
        1间隔时间不精确，可能被阻塞。计时器的间隔指的是将回调函数推入任务队列的间隔时间，任务队列中的任务只有在主线程任务执行完毕后才会被执行。
        2计时器动画的间隔时间如果设定过短就会出现过度渲染占用大量资源，如果设定过长就会影响动画的流畅度。只能够估计合适的时间间隔。
        3多数浏览器对于计时器动画没有优化
    setTimeout
        requestAnimationFrame 动画的帧数是由系统根据当前页面是否可见，CPU 的占用情况等等来决定的，可以最大化地利用系统性能。
        浏览器对 requestAnimationFrame 动画进行了优化。

/*************************************************************************************************/
17.js单线程,异步,同步概念(https://www.cnblogs.com/sunmarvell/p/9564815.html)(https://www.cnblogs.com/hity-tt/p/6733062.html)(https://blog.csdn.net/RedaTao/article/details/81504532)
    js单线程:js是单线程的(如果一个线程删除dom,一个线程增加dom,浏览器会傻逼.所以只能单着了),虽然webWorker的多线程出现,但也是在主线程的控制下
            webWorker仅仅能进行计算任务,不能操作dom,所以本质上还是单线程
            单线程即任务是串行的,后一个任务需要等前一个任务执行,这可能出现长时间等待,
    异步:但由于类似ajax网络请求,setTimeout时间延长,dom事件的用户交互等,这些任务并不消耗cpu,是一种空等,资源浪费,因此出现了异步,通过将任务交给相应的异步模块去处理,主线程效率大大提升，当异步处理完成,
            主线程空闲时,主线程读取相应的callback,进行后续的操作,最大程度利用cpu
    总结:因此出现了同步执行和异步执行,同步执行时主线程按照顺序,串行执行任务,异步执行就是cpu跳过等待,先处理后续的任务.由此产生了任务队列与事件循环,来协调主线程与异步模块之间的工作

    文字描述
        1同步和异步任务分别进入不同的执行"场所",同步的进入主线程,异步的进入Event Table并注册函数(回调函数)
        2当指定的事情完成时,Event Table会将这个函数移入Event Queue
        3主线程内的任务执行完毕为空,会去Event Queue读取对应的函数,进入主线程执行
        4上述过程会不断重复,也就是常说的Event Loop(事件循环)
    js主线程:js一直在做这一个工作,就是从任务队列里提取任务,放到主线程里执行
            1所有同步任务都在主线程上执行,形成一个执行栈
            2主线程之外,还存在一个"任务队列"。只要异步任务有了运行结果,就在"任务队列"之中放置一个事件
            3一旦"执行栈"中的所有同步任务执行完毕,系统就会读取"任务队列",看看有哪些事件,哪些对应的异步任务,于是结束等待状态,进入执行栈,开始执行
            4主线程不断重复上面的第三部
    异步任务:有分为宏任务和微任务(异步任务里面先执行微任务,在执行宏任务)
        宏任务: 宏任务一般包括：整体代码script，setTimeout，setInterval
        微任务:Promise，process.nextTick
/*************************************************************************************************/
18浏览器是否会发送图片请求？元素隐藏display:none,class不存在的元素背景图片(https://blog.csdn.net/clear_love8/article/details/97632574)
    1. 隐藏图片
        <img src="haorooms.jpg" style="display: none" />  
        结论：只有Opera不产生请求。 注意：用visibility: hidden隐藏图片时，在Opera下也会产生请求。
    2. 重复图片
        <img src="haorooms.jpg" />  
        <img src="haorooms.jpg" />  
        结论：所有浏览器都只产生一次请求 。
    3. 重复背景
        <style type="text/css">   
        .test1 { background: url(haorooms.jpg) }   
        .test2 { background: url(haorooms.jpg) }   
        </style>   
        <div class="test1">test1</div>   
        <div class="test2">test2</div> 
        结论：所有浏览器都只产生一次请求
    4. 不存在的元素的背景
        <style type="text/css">   
        .test1 { background: url(haorooms.jpg) }   
        .test2 { background: url(http2.jpg) } /* 页面中没有class为test2的元素 */  
        </style>   
        <div class="test1">test1</div>  
        结论：背景仅在应用的元素在页面中存在时，才会产生请求。这对CSS框架来说，很有意义。
    5.隐藏元素的背景
        <style type="text/css">   
        .test1 { background: url(haorooms.jpg); display: none; }   
        .test2 { background: url(http2.jpg); visibility: hidden; }   
        </style>   
        <div class="test1">test1</div> 
        结论：Opera和Firefox对于用display: none隐藏的元素背景，不会产生HTTP请求。仅当这些元素非display: none时，才会请求背景图片。
    6.多重背景
        <style type="text/css">   
        .test1 { background: url(haorooms.jpg); }   
        .test1 { background: url(http2.jpg); }   
        </style>   
        <div class="test1">test1</div>  
        上面这段代码的http请求，只会请求http2.jpg这一张图片，原因是test1的class把上面的给覆盖掉了，所有只请求后面的一张图片！
    假如用css3多张背景图片的写法：
        <style type="text/css">   
        .test1 { background-image:url("haorooms.jpg"),url("http2.jpg"); }   
        </style>   
        <div class="test1">test1</div> 
        webkit引擎浏览器对背景图都请求，是因为支持CSS3中的多背景图。
